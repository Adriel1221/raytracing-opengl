#version 430

#define MAX_RECURSION_DEPTH 5

#define T_MIN 0.001f
#define REFLECT_BIAS 0.001f
#define SHADOW_BIAS 0.0001f

#define FLT_MIN 1.175494351e-38
#define FLT_MAX 3.402823466e+38

#define LIGHT_AMBIENT 0
#define LIGHT_POINT 1
#define LIGHT_DIRECT 2

#define SHADOW_ENABLED 1
#define DBG 0

#define MULTI_INTERSECTION 1
#define CUSTOM_REFRACT 1
#define TOTAL_INTERNAL_REFLECTION 1
#define REFRACTIVE_INDEX_AIR 1.00029
#define DO_FRESNEL 1
#define LIGHT_AMBIENT2 vec3(0.0)

#define AIM_ENABLED 1

struct rt_sphere {
	vec4 center;
	vec4 color;
	float radius;
	float reflect;
	int specular;
	float refract;
};

struct rt_light {
	vec4 position;
	vec4 direction;

    int type;
	float intensity;
};

struct rt_scene {
	vec4 camera_pos;
    vec4 quat_camera_rotation;
	vec4 bg_color;

	int canvas_width;
	int canvas_height;
	float viewport_width;
	float viewport_height;

	float viewport_dist;
	int reflect_depth;
	int sphere_count;
	int light_count;
};

layout (local_size_x = 16, local_size_y = 16) in;
layout (rgba32f, binding = 0) uniform image2D img_output;

layout( std430, binding=1 ) readonly buffer scene_buf
{
    rt_scene scene;
};

layout( std430, binding=2 ) readonly buffer spheres_buf
{
    rt_sphere spheress[ ];
};

layout( std430, binding=3 ) readonly buffer lights_buf
{
    rt_light lightss[ ];
};
const int iterations = 5;
const float maxDist = 1000.0;
const vec3 amb = vec3(1.0);
const float eps = 0.001;

// struct Camera
// {
// 	vec3 up, right, forward;
// 	vec3 position;
// };

//Camera cam;
#define sp_size 11

vec4 spheres[sp_size];
vec4 colors[sp_size];
vec2 materials[sp_size];

void init()
{
    // X Y Z Radius
    spheres[0] = vec4(      0.8,       0,    -1.5,    0.1);
    spheres[1] = vec4(      -0.8,    0.25,    -1.5,    0.1);
    spheres[2] = vec4(      0,    -0.7,    -1.5,    0.3);
    spheres[3] = vec4(      0,    -0.1,    -0.5,    0.3);
    spheres[4] = vec4(      0,    -0.1,    -1.5,    0.15);
    spheres[5] = vec4( 1001.0,       0,       0, 1000.0); 
    spheres[6] = vec4(-1001.0,       0,       0, 1000.0);
    spheres[7] = vec4(      0,  1001.0,       0, 1000.0); 
    spheres[8] = vec4(      0, -1001.0,       0, 1000.0);
    spheres[9] = vec4(      0,       0, -1002.0, 1000.0);
	spheres[10] = vec4(      0,    -0.1,    -1,    0.15);

    //R G B Diffuse
    colors[0] = vec4(1.0, 0.8, 0.0,-1.0);
    colors[1] = vec4(0.0, 0.0, 1.0,-1.0);
    colors[2] = vec4(1.0, 1.0, 1.0, 1.0);
    colors[3] = vec4(1.0, 1.0, 1.0, 1.0);
    colors[4] = vec4(1.0, 0.0, 0.0, 1.0);
    colors[5] = vec4(0.0, 1.0, 0.0, 0.7);
    colors[6] = vec4(1.0, 0.0, 0.0, 0.7);
    colors[7] = vec4(1.0, 1.0, 1.0, 0.7);
    colors[8] = vec4(1.0, 1.0, 1.0, 0.7);
    colors[9] = vec4(1.0, 1.0, 1.0, 0.7);
	colors[10] = vec4(1.0, 0.0, 0.0, 0.5);

    //Reflection Coeff, Refraction index
    materials[0] = vec2 (0.0, 0.0);
    materials[1] = vec2 (0.0, 0.0);				
    materials[2] = vec2 (1.0, 0.0);	
    materials[3] = vec2 (0.1, 1.125);	
    materials[4] = vec2 (0.1, 1.25);
    materials[5] = vec2 (0.0, 0.0);				
    materials[6] = vec2 (0.0, 0.0);				
    materials[7] = vec2 (0.1, 0.0);				
    materials[8] = vec2 (0.1, 0.0);				
    materials[9] = vec2 (0.1, 0.0);
	materials[10] = vec2 (0.2, 0.0);	

    // cam.up       = vec3(0.0, 1.0, 0.0);
    // cam.right    = vec3(1.0, 0.0, 0.0);
    // cam.forward  = vec3(0.0, 0.0,-1.0);
    // cam.position = vec3(0.0, 0.0,-0.2);
}

// vec3 getRayDir(vec2 fragCoord)
// {
//   vec2 uv = (gl_GlobalInvocationID.xy / iResolution.xy )*2.0 - 1.0;
//   uv.x *= iResolution.x/iResolution.y;                   
//   return normalize(uv.x * cam.right + uv.y * cam.up + cam.forward);
// }

vec4 multiplyQuaternion(vec4 q1, vec4 q2) {
	vec4 result;

	result.w = q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z;
	result.x = q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y;
	result.y = q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z;
	result.z = q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x;

	return result;
}

vec3 Rotate(vec4 q, vec3 v)
{
	vec4 qv = vec4(v, 0);

	vec4 mult = multiplyQuaternion(q, qv);
	float scale = 1 / (q.w * q.w + dot(q, q));
	vec4 inverse = - scale * q;
	inverse.w = scale * q.w;
	vec3 result = vec3(multiplyQuaternion(mult, inverse));

	return result;
}

vec3 getRayDir(ivec2 pixel_coords)
{
	//vec2 uv = (pixel_coords.xy / vec2(scene.canvas_width, scene.canvas_height)) * 2.0 - 1.0;


	int x = int (pixel_coords.x - scene.canvas_width / 2.0);
	int y = int (pixel_coords.y - scene.canvas_height / 2.0);
	//vec2 uv = vec2(x,y); //* (scene.canvas_width / scene.canvas_height);
	//uv.x *= scene.canvas_width / scene.canvas_height;
	//return normalize(uv.x * cam.right + uv.y * cam.up + cam.forward);

	vec3 result = vec3(
		x * scene.viewport_width / scene.canvas_width,
	 	y * scene.viewport_height / scene.canvas_height,
	 	scene.viewport_dist);
	// return result;
	return normalize(Rotate(scene.quat_camera_rotation, result));
}


// The Intersection funtions and shading funcs are taken from inigo's article:
// http://www.iquilezles.org/www/articles/simplegpurt/simplegpurt.htm

bool intersectSphere(vec3 ro, vec3 rd, vec4 sp, float tm, out float t)
{
    bool r = false;
	vec3 v = ro - sp.xyz;
	float b = dot(v,rd);
	float c = dot(v,v) - sp.w*sp.w;
	t = b*b-c;
    if( t > 0.0 )
    {
		float sqrt_ = sqrt(t);
		t = -b - sqrt_;
		#if MULTI_INTERSECTION
		if (t < 0.0) t = - b + sqrt_;
		#endif
		r = (t > 0.0) && (t < tm);
    }
    return r;
}

float calcInter(vec3 ro, vec3 rd, out vec4 ob, out vec4 col,out vec2 mat)
{
	float tm = maxDist;
	float t;

	if(intersectSphere(ro,rd,spheres[0],tm,t)) { ob = spheres[0]; col = colors[0]; tm = t; mat = materials[0]; }
	if(intersectSphere(ro,rd,spheres[1],tm,t)) { ob = spheres[1]; col = colors[1]; tm = t; mat = materials[1]; }
	if(intersectSphere(ro,rd,spheres[2],tm,t)) { ob = spheres[2]; col = colors[2]; tm = t; mat = materials[2]; }
	if(intersectSphere(ro,rd,spheres[3],tm,t)) { ob = spheres[3]; col = colors[3]; tm = t; mat = materials[3]; }
	//if(intersectSphere(ro,rd,spheres[4],tm,t)) { ob = spheres[4]; col = colors[4]; tm = t; mat = materials[4]; }
	if(intersectSphere(ro,rd,spheres[5],tm,t)) { ob = spheres[5]; col = colors[5]; tm = t; mat = materials[5]; }
	if(intersectSphere(ro,rd,spheres[6],tm,t)) { ob = spheres[6]; col = colors[6]; tm = t; mat = materials[6]; }
	if(intersectSphere(ro,rd,spheres[7],tm,t)) { ob = spheres[7]; col = colors[7]; tm = t; mat = materials[7]; }
	if(intersectSphere(ro,rd,spheres[8],tm,t)) { ob = spheres[8]; col = colors[8]; tm = t; mat = materials[8]; }
    if(intersectSphere(ro,rd,spheres[9],tm,t)) { ob = spheres[9]; col = colors[9]; tm = t; mat = materials[9]; }
	//if(intersectSphere(ro,rd,spheres[10],tm,t)) { ob = spheres[9]; col = colors[10]; tm = t; mat = materials[10]; }

	return tm;
}

bool inShadow(vec3 ro,vec3 rd,float d)
{
	float t;
	bool ret = false;

	if(intersectSphere(ro,rd,spheres[2],d,t)){ ret = true; }
	if(intersectSphere(ro,rd,spheres[3],d,t)){ ret = true; }
	//if(intersectSphere(ro,rd,spheres[4],d,t)){ ret = true; }
	if(intersectSphere(ro,rd,spheres[5],d,t)){ ret = true; }
	if(intersectSphere(ro,rd,spheres[6],d,t)){ ret = true; }
	if(intersectSphere(ro,rd,spheres[7],d,t)){ ret = true; }
	if(intersectSphere(ro,rd,spheres[8],d,t)){ ret = true; }
	if(intersectSphere(ro,rd,spheres[9],d,t)){ ret = true; }
	//if(intersectSphere(ro,rd,spheres[10],d,t)){ ret = true; }

	return ret;
}

vec3 LightPixel2 (vec3 pt, vec3 rd, vec3 diffuse, vec4 col, vec3 n, float specPower, bool doShadow)
{
	float dist,diff;
	vec3 lcol,l;
	vec3 ambcol = amb * (1.0-col.w) * col.rgb;
	vec3 scol = col.w * col.rgb;

	vec3 pixelColor = diffuse * LIGHT_AMBIENT2 * col.w;
	if(col.w > 0.0) //If its not a light
	{
		for (int i = 0; i < 2; i++)
		{
			l = spheres[i].xyz - pt;
			dist = length(l);
			l = normalize(l);
			lcol = colors[i].rgb;
			diff = dot(n,l);
			//проверить normal.y - что делает
			if (doShadow && diff >= 0 && inShadow(pt, l, dist)) {
				continue;
			}

			// diffuse
			float dp = clamp(dot(n, l), 0.0, 1.0);
			pixelColor += ( 
				//ambcol * lcol + scol * 
				dp * lcol 
				* diffuse
				 ) / (1.0+dist*dist);

			// // specular highlight
			// if (specPower > 0.0)
			// {
			// 	vec3 reflection = reflect(-LIGHT_DIRECTIONAL_DIR, normal);
			// 	dp = clamp(dot(rayDir, reflection), 0.0, 1.0);
			// 	pixelColor += LIGHT_DIRECTIONAL_COLOR * pow(dp, specPower);    
			// }

			//pixelColor += ;	

			
			// dist = length(l);
			// l = normalize(l);
			// lcol = colors[0].rgb;
			// diff = dot(n,l);
			// if (diff >= 0){
			// 	c_color = (ambcol * lcol + lcol * diff * scol) / (1.0+dist*dist);
			// 	if(inShadow(pt,l,dist))
			// 		c_color *= 0.0;
			// 	color += c_color;
			// }
		}
	} else return diffuse;
	return pixelColor;
}

// vec3 LightPixel (vec3 rayPos, vec3 rayDir, vec3 diffuse, vec3 normal, float specPower, bool doShadow)
// {   
//     // ambient
//     vec3 pixelColor = diffuse * LIGHT_AMBIENT2;

	
    
//     // see if we are in shadow by casting in the light direction and seeing if we hit the object.
//     // if we do hit the object, return just the ambient lighting shaded color we have already calculated.
//     if (doShadow && normal.y >= 0.9 && RayIntersectObject(rayPos, -LIGHT_DIRECTIONAL_DIR).x >= 0.0)
//         return pixelColor;
    
//     // diffuse
//     float dp = clamp(dot(normal, -LIGHT_DIRECTIONAL_DIR), 0.0, 1.0);
//     pixelColor += diffuse * dp * LIGHT_DIRECTIONAL_COLOR;
    
//     // specular highlight
//     if (specPower > 0.0)
//     {
//     	vec3 reflection = reflect(-LIGHT_DIRECTIONAL_DIR, normal);
//     	dp = clamp(dot(rayDir, reflection), 0.0, 1.0);
// 		pixelColor += LIGHT_DIRECTIONAL_COLOR * pow(dp, specPower);    
//     }
    
//     return pixelColor;
// }

vec3 calcShade(vec3 pt, vec4 ob, vec4 col,vec2 mat,vec3 n)
{

	float dist,diff;
	vec3 lcol,l;

	vec3 color = vec3(0.0);
	vec3 ambcol = amb * (1.0-col.w) * col.rgb;
	vec3 scol = col.w * col.rgb;
	vec3 c_color;

	if(col.w > 0.0) //If its not a light
	{
		l = spheres[0].xyz - pt;
		dist = length(l);
		l = normalize(l);
		lcol = colors[0].rgb;
		diff = dot(n,l);
		if (diff >= 0){
			c_color = (ambcol * lcol + lcol * diff * scol) / (1.0+dist*dist);
			if(inShadow(pt,l,dist))
				c_color *= 0.0;
			color += c_color;
		}
		

		l = spheres[1].xyz - pt;
		dist = length(l);
		l = normalize(l);
		vec3 lcol = colors[1].rgb;
		diff = dot(n,l);
		if (diff >= 0){
			c_color = (ambcol * lcol + lcol * diff * scol) / (1.0+dist*dist);
			if(inShadow(pt,l,dist))
				c_color *= 0.0;
			color += c_color;
		}
	}
	else
		color = col.rgb;

	return color;
}

float getFresnel(vec3 n,vec3 rd,float r0)
{
    float ndotv = clamp(dot(n, -rd), 0.0, 1.0);
	return r0 + (1.0 - r0) * pow(1.0 - ndotv, 5.0);
}

float FresnelReflectAmount (float n1, float n2, vec3 normal, vec3 incident, float refl)
{
    #if DO_FRESNEL
        // Schlick aproximation
        float r0 = (n1-n2) / (n1+n2);
        r0 *= r0;
        float cosX = -dot(normal, incident);
        if (n1 > n2)
        {
            float n = n1/n2;
            float sinT2 = n*n*(1.0-cosX*cosX);
            // Total internal reflection
            if (sinT2 > 1.0)
                return 1.0;
            cosX = sqrt(1.0-sinT2);
        }
        float x = 1.0-cosX;
        float ret = r0+(1.0-r0)*x*x*x*x*x;

        // adjust reflect multiplier for object reflectivity
        ret = (refl + (1.0-refl) * ret);
        return ret;
    #else
    	return refl;
    #endif
}

vec3 getReflection(vec3 ro,vec3 rd)
{
	vec3 color = vec3(0);
	vec4 ob,col;
    vec2 mat;
	float tm = calcInter(ro,rd,ob,col,mat);
	if(tm < maxDist)
	{
		vec3 pt = ro + rd*tm;
		vec3 n = normalize(pt - ob.xyz);
		bool outside = dot(rd, n) < 0;
		color = calcShade(outside ? pt + n * eps : pt - n * eps,ob,col,mat,n);
	}
	return color;
}

void swap(inout float a, inout float b)
{
	float tmp = a;
	a = b;
	b = tmp;
}

vec3 refract_c(vec3 I, vec3 N, float ior)
{
	float cosi = clamp(dot(I, N), -1, 1);
	float etai = 1, etat = ior;
	vec3 n = N;
	if (cosi < 0) { cosi = -cosi; }
	else { swap(etai, etat); n = -N; }
	float eta = etai / etat;
	float k = 1 - eta * eta * (1 - cosi * cosi);
	return k < 0.0 ? vec3(0.0) : eta * I + (eta * cosi - sqrt(k)) * n;

	//float k = 1.0 - eta * eta * (1.0 - N.dotProduct(I) * N.dotProduct(I));
	//if (k < 0.0)
	//	return vec3(0.0);       // or genDType(0.0)
	//else
	//	return  eta * I - (eta * N.dotProduct(I) + sqrt(k)) * N;
}


void main()
{
	ivec2 pixel_coords = ivec2 (gl_GlobalInvocationID.xy);
	if (pixel_coords.x >= scene.canvas_width || pixel_coords.y >= scene.canvas_height) return;
	#if AIM_ENABLED
	if (pixel_coords == ivec2(scene.canvas_width / 2, scene.canvas_height / 2))
	{
		imageStore(img_output, pixel_coords, vec4(1,1,1,0));
		return;
	}
	#endif	

    init();
	float reflectMultiplier,refractMultiplier,tm;
	vec4 ob,col;
    vec2 mat;
	vec3 pt,refCol,n,refl;

	vec3 mask = vec3(1.0);
	vec3 color = vec3(0.0);
	vec3 ro = vec3(scene.camera_pos);
	vec3 rd = getRayDir(pixel_coords);
	
	for(int i = 0; i < iterations; i++)
	{
		tm = calcInter(ro,rd,ob,col,mat);
		if(tm < maxDist)
		{
			pt = ro + rd*tm;
			n = normalize(pt - ob.xyz);
			//fresnel = getFresnel(n,rd,mat.x);
			//mask *= fresnel;
			bool outside = dot(rd, n) < 0;

			#if TOTAL_INTERNAL_REFLECTION
			//float reflIdx = mat.y > 0 ? mat.y : REFRACTIVE_INDEX_AIR;
			if (mat.y > 0) 
				reflectMultiplier = FresnelReflectAmount( outside ? REFRACTIVE_INDEX_AIR : mat.y,
													  	  outside ? mat.y : REFRACTIVE_INDEX_AIR,
											 		      rd, n, mat.x);
			else reflectMultiplier = getFresnel(n,rd,mat.x);
			#else
			reflectMultiplier = getFresnel(n,rd,mat.x);
			#endif
			refractMultiplier = 1 - reflectMultiplier;

			if(mat.y > 0.0) // Refractive
			{
				if (outside)
				{
					refl = reflect(rd, n);
					refCol = getReflection(outside ? pt + n * eps : pt - n * eps, refl);
					color += refCol * reflectMultiplier * mask;
					mask *= refractMultiplier;
				}
				#if TOTAL_INTERNAL_REFLECTION
				if (reflectMultiplier >= 1)
				 	break;
				#endif
				ro = outside ? pt - n * eps : pt + n * eps;
				#if CUSTOM_REFRACT
				rd = refract_c(rd, n, mat.y);
				#else
				float refractCoeff = outside ? REFRACTIVE_INDEX_AIR / mat.y : mat.y / REFRACTIVE_INDEX_AIR;
				rd = refract(rd, outside ? n : -n, refractCoeff);
				#endif
			}
			else 
			if(mat.x > 0.0) // Reflective
			{
				ro = outside ? pt + n * eps : pt - n * eps;
				//color += calcShade(ro,ob,col,mat,outside ? n : -n) * refractMultiplier * mask;
				color += LightPixel2(ro, rd, col.rgb, col, outside ? n : -n, 500.0, true)* refractMultiplier * mask;
				rd = reflect(rd, n);
				mask *= reflectMultiplier;
			}
			else // Diffuse
            {
				//color += calcShade(outside ? pt + n * eps : pt - n * eps,ob,col,mat,outside ? n : -n) * mask;
				//(vec3 pt, vec3 rd, vec3 diffuse, vec4 col, vec3 n, float specPower, bool doShadow)
				color += LightPixel2(outside ? pt + n * eps : pt - n * eps, rd, col.rgb, col, outside ? n : -n, 500.0, true) * mask;
                break;
            }
			
		}
	}
	
	imageStore (img_output, pixel_coords, vec4(color,0));
	//imageStore(img_output,);
	//fragColor = vec4(color,1.0);
}