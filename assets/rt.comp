#version 430
#define MAX_RECURSION_DEPTH 5
#define SHADOW_ENABLED 1
#define T_MIN 0.05f
#define FLT_MIN 1.175494351e-38
#define FLT_MAX 3.402823466e+38

#define LIGHT_AMBIENT = 0
#define LIGHT_POINT = 1
#define LIGHT_DIRECT = 2

struct rt_sphere {
	vec4 center;
	vec4 color;
	float radius;
	float reflect;
	int specular;
};

struct rt_light {
	vec4 position;
	vec4 direction;

    int type;
	float intensity;
};

struct rt_scene {
	vec4 camera_pos;
    vec4 quat_camera_rotation;
	vec4 bg_color;

	int canvas_width;
	int canvas_height;
	float viewport_width;
	float viewport_height;

	float viewport_dist;
	int reflect_depth;
	int sphere_count;
	int light_count;
};

layout (local_size_x = 16, local_size_y = 16) in;
layout (rgba32f, binding = 0) uniform image2D img_output;

layout( std430, binding=1 ) readonly buffer scene_buf
{
    rt_scene scene;
};

layout( std430, binding=2 ) readonly buffer spheres_buf
{
    rt_sphere spheres[ ];
};

layout( std430, binding=3 ) readonly buffer lights_buf
{
    rt_light lights[ ];
};

void __dbg()
{
	ivec2 pixel_coords = ivec2 (gl_GlobalInvocationID.xy);
    imageStore (img_output, pixel_coords, vec4(1,0,0,0));
}

vec4 multiplyQuaternion(vec4 q1, vec4 q2) {
	vec4 result;

	result.w = q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z;
	result.x = q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y;
	result.y = q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z;
	result.z = q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x;

	return result;
}

vec4 Rotate(vec4 q, vec4 v)
{
	vec4 qv = v;
	qv.w = 0;

	vec4 tmp = q;
	vec4 mult = multiplyQuaternion(tmp, qv);
	vec4 inverse;
	float scale = 1 / (q.w * q.w + dot(q, q));
	inverse = - scale * q;
	inverse.w = scale * q.w;
	vec4 result = multiplyQuaternion(mult, inverse);

	return result;
}

vec4 CanvasToViewport(ivec2 pixel_coords)
{
	int x = int (pixel_coords.x - scene.canvas_width / 2.0);
	int y = int (pixel_coords.y - scene.canvas_height / 2.0);

	vec4 result = vec4(
		x * scene.viewport_width / scene.canvas_width,
		y * scene.viewport_height / scene.canvas_height,
		scene.viewport_dist,
		0);
	return result;
	//return Rotate(scene.quat_camera_rotation, result);
}

float IntersectRaySphere(vec4 o, vec4 d, float tMin, int sphereIndex)
{
	float t1, t2;

	vec4 c = spheres[sphereIndex].center;
	float r = spheres[sphereIndex].radius;
	vec4 oc = o - c;

	float k1 = dot(d, d);
	float k2 = 2 * dot(oc, d);
	float k3 = dot(oc, oc) - r * r;
	float discr = k2 * k2 - 4 * k1 * k3;

	if (discr < 0)
	{
		return -1;
	}
	else
	{
		t1 = (-k2 + sqrt(discr)) / (2 * k1);
		t2 = (-k2 - sqrt(discr)) / (2 * k1);
	}
	if (t1 <= t2 && t1 >= tMin)
	{
		return t1;
	}
	else if (t2 <= t1 && t2 >= tMin)
	{
		return t2;
	}
	else 
	{
		return -1;
	}
}

vec4 ReflectRay(vec4 r, vec4 normal) {
	return 2 * normal * dot(r, normal) - r;
}

void ClosestIntersection(vec4 o, vec4 d, float tMin, float tMax, out float t, out int sphereIndex) {
	float closest = FLT_MAX;
	int sphere_index = -1;

	for (int i = 0; i < scene.sphere_count; i++)
	{
		float intersect = IntersectRaySphere(o, d, tMin, i);

		if (intersect >= tMin && intersect <= tMax && intersect < closest)
		{
			closest = t;
			sphere_index = i;
		}
	}

	t = closest;
	sphereIndex = sphere_index;
}

vec4 TraceRay(vec4 o, vec4 d, float tMin, float tMax)
{
	if (scene.reflect_depth == 0) return vec4(0,0,0,0);

	float closest;
	int sphere_index;

	vec4 colors[MAX_RECURSION_DEPTH];
    float reflects[MAX_RECURSION_DEPTH];

	int recursionCount = 0;

	//for (int i = 0; i < scene.reflect_depth; i++)
	//{
		ClosestIntersection(o, d, tMin, tMax, closest, sphere_index);
		
		if (sphere_index == -1)
		{
			return scene.bg_color;

			// colors[recursionCount] = scene->bg_color;
			// reflects[recursionCount] = 0;
			// ++recursionCount;
			// break;
		}
		vec4 p = o + (d * closest);
		vec4 normal = normalize(p - spheres[sphere_index].center);

		//good for surfaces, bad for box, sphere
		// if (dot(normal, d) > 0)
		// {
		// 	normal = -normal;
		// }
		vec4 view = -d;
		return spheres[sphere_index].color;

		// colors[recursionCount] = sphere->color * ComputeLighting(p, normal, scene, view, sphere->specular);
		// reflects[recursionCount] = sphere->reflect;
		// ++recursionCount;
		// if (sphere->reflect <= 0 || scene->reflect_depth == 1)
		// 	break;

		// if (i < scene->reflect_depth - 1) {
		// 	//setup for next iteration
		// 	o = p;
		// 	d = ReflectRay(view, normal);
		// }
	//}

	// if (recursionCount <= 1)
	//  	return colors[0];

	// float4 totalColor = colors[recursionCount - 1];

	// for(int i = recursionCount - 2; i >= 0; i--)
	// {
	// 	float reflect = reflects[i];
	// 	float4 prevColor = colors[i];
	// 	totalColor = prevColor * (1 - reflect) + totalColor * reflect;
	// }

	// return totalColor;
}

void main () 
{
	ivec2 pixel_coords = ivec2 (gl_GlobalInvocationID.xy);
	if (pixel_coords.x > scene.canvas_width || pixel_coords.y > scene.canvas_height) return;

	vec4 d = CanvasToViewport(pixel_coords);
	vec4 color = TraceRay(scene.camera_pos, d, T_MIN, FLT_MAX);
    imageStore (img_output, pixel_coords,color);
}                                                             